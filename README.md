# ğŸ§  JSON Repair Doctor v3.8

### Fast, schemaâ€‘guided repair engine for broken LLM JSON

Repair malformed JSON generated by AI systems, agents, planners, tools,
scripts, and automation pipelines --- safely, deterministically, and
without infinite loops.

------------------------------------------------------------------------

# âœ¨ What is this?

**JSON Repair Doctor** converts **invalid, broken, messy, AIâ€‘generated
JSONâ€‘like text into strict valid JSON**.

It is purposeâ€‘built for modern AI systems that must produce structured
output but often fail to produce valid syntax.

Typical environments:

-   LLM tool calling
-   AI planners
-   automation agents
-   code generators
-   workflow engines
-   terminal execution agents
-   function calling pipelines
-   structured response APIs

If an AI produces **almost JSON** --- this fixes it.

------------------------------------------------------------------------

# â— The Problem This Solves

AI frequently produces **JSONâ€‘like but invalid structures**:

-   missing commas
-   missing colons
-   invalid quoting
-   unescaped characters
-   mixed Python / JS / JSON syntax
-   nested structure corruption
-   schema type mismatch
-   broken escape sequences
-   planner step corruption
-   deeply nested container confusion

Example (real AI output):

``` json
{
  steps: [
    {id: "1" action: run},
    {id: 2 action: "stop"}
  ]
}
```

Not valid JSON.\
Downstream systems crash.

This engine repairs automatically.

------------------------------------------------------------------------

# ğŸ¯ Design Goals

âœ” Deterministic repair\
âœ” Strict JSON output\
âœ” No infinite loops\
âœ” No silent truncation\
âœ” Schemaâ€‘aware correction\
âœ” Minimal data loss\
âœ” Deep nesting support\
âœ” Production safe

------------------------------------------------------------------------

# ğŸ§© What It Repairs Automatically

### Syntax

-   missing commas
-   missing colons
-   trailing commas
-   semicolons
-   adjacent objects
-   comments

### Quotes

-   single â†’ double
-   smart quotes
-   unescaped inner quotes
-   broken escape sequences
-   unterminated strings

### Literals

-   True / False / None
-   undefined
-   NaN / Infinity
-   BigInt 123n

### Containers

-   tuples â†’ arrays
-   sets â†’ arrays
-   new Set / new Map
-   mixed nested structures

### Numbers

-   hex â†’ decimal
-   leading zeros
-   signed values

### Extraction

-   markdown fences
-   natural language wrappers
-   partial roots

------------------------------------------------------------------------

# ğŸ§¬ Schemaâ€‘Guided Repair (Advanced)

When schema is provided, engine becomes **semantic aware**.

It can:

âœ” fix ambiguous quotes\
âœ” coerce types\
âœ” inject missing fields\
âœ” repair nested structures\
âœ” repair broken values\
âœ” repair keys\
âœ” detect wrapped lists\
âœ” recursively repair subtrees

------------------------------------------------------------------------

# ğŸ“¦ Installation

Copy file into project:

    json_repair_v38_locked.py

Optional speed boost:

    pip install orjson

------------------------------------------------------------------------

# ğŸš€ Basic Usage

``` python
from json_repair_v38_locked import repair_json

fixed = repair_json(broken_json)
```

Return Python object:

``` python
obj = repair_json(broken_json, return_dict=True)
```

Schema guided:

``` python
schema = {"name": str, "score": float}
obj = repair_json(broken, return_dict=True, schema=schema)
```

------------------------------------------------------------------------

# ğŸ§ª BEFORE vs AFTER --- REAL REPAIR EXAMPLES

------------------------------------------------------------------------

## ğŸ”¹ Example 1 --- Nested Dictionary Repair (No Schema)

### Broken

``` json
{
 user: {
   name: "Alice"
   age: 30
   address: {city: London zip: 12345}
 }
}
```

### Fixed

``` json
{
  "user": {
    "name": "Alice",
    "age": 30,
    "address": {
      "city": "London",
      "zip": 12345
    }
  }
}
```

------------------------------------------------------------------------

## ğŸ”¹ Example 2 --- Deeply Nested List + Dict + Tuple

### Broken

``` json
{
 data: [
   (1,2,3),
   {scores:[10 20 30], status: active},
   new Set([4,5,6])
 ]
}
```

### Fixed

``` json
{
  "data": [
    [1, 2, 3],
    {
      "scores": [10, 20, 30],
      "status": "active"
    },
    [4, 5, 6]
  ]
}
```

------------------------------------------------------------------------

## ğŸ”¹ Example 3 --- Dictionary Inside Dictionary Inside List

### Broken

``` json
[
 {user:{id:"1" name:"Alice"}},
 {user:{id:2 name:"Bob"}}
]
```

### Fixed

``` json
[
  {"user": {"id": "1", "name": "Alice"}},
  {"user": {"id": 2, "name": "Bob"}}
]
```

------------------------------------------------------------------------

## ğŸ”¹ Example 4 --- Tuple + Set + Object Mixed

### Broken

``` json
{
 config:(mode:fast retries:3),
 tags:{a,b,c}
}
```

### Fixed

``` json
{
  "config": {
    "mode": "fast",
    "retries": 3
  },
  "tags": ["a","b","c"]
}
```

------------------------------------------------------------------------

# ğŸ§  SCHEMA REPAIR EXAMPLES

------------------------------------------------------------------------

## ğŸ”¹ Example 5 --- Type Coercion Inside Nested Object

### Broken

``` json
{
 user:{
   id:"10",
   score:"95.5",
   active:"true"
 }
}
```

### Schema

``` python
{"user":{"id":int,"score":float,"active":bool}}
```

### Fixed

``` json
{
  "user": {
    "id": 10,
    "score": 95.5,
    "active": true
  }
}
```

------------------------------------------------------------------------

## ğŸ”¹ Example 6 --- Missing Fields Injected

### Broken

``` json
{name:"Alice"}
```

### Schema

``` python
{"name":str,"age":int,"active":bool}
```

### Fixed

``` json
{
  "name":"Alice",
  "age":null,
  "active":null
}
```

------------------------------------------------------------------------

## ğŸ”¹ Example 7 --- Nested List of Objects (Schema)

### Broken

``` json
{
 users:[
   {id:"1" score:"90"},
   {id:2 score:85}
 ]
}
```

### Schema

``` python
{"users":[{"id":int,"score":float}]}
```

### Fixed

``` json
{
  "users":[
    {"id":1,"score":90.0},
    {"id":2,"score":85.0}
  ]
}
```

------------------------------------------------------------------------

## ğŸ”¹ Example 8 --- Planner Step Repair (Real Agent Output)

### Broken

``` json
{
 steps:[
   {step_id:"1" tool:terminal confidence:"0.9"}
   {step_id:2 tool:terminal confidence:0.8}
 ]
}
```

### Schema

``` python
{"steps":[{"step_id":int,"tool":str,"confidence":float}]}
```

### Fixed

``` json
{
  "steps":[
    {"step_id":1,"tool":"terminal","confidence":0.9},
    {"step_id":2,"tool":"terminal","confidence":0.8}
  ]
}
```

------------------------------------------------------------------------

# ğŸš« What It Will NOT Do

The engine never invents missing information.

It raises error when repair is impossible.

------------------------------------------------------------------------

# âš¡ Performance

-   linear time pipeline
-   bounded token repair
-   early parse exit
-   strict validation

------------------------------------------------------------------------

# ğŸ›¡ï¸ Safety Guarantees

âœ” no infinite loops\
âœ” deterministic output\
âœ” strict JSON only

------------------------------------------------------------------------

# ğŸ“„ License

MIT License
